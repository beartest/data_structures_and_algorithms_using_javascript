第14章 高级算法
	动态规划和贪心算法。
	动态规划有时被认为是一种与递归相反的技术。递归是从顶部开始将问题分解，通过解决掉所有分解出来的小问题的方式，来解决整个问题。动态规划解决方案是从底部开始解决问题，将所有的小问题解决掉，然后合并成一个整体解决方案，从而解决整个大问题。
	贪心算法是一种以寻找“优质解”为手段从而达成整体解决方案的算法。这些优质的解决方案被称为“局部最优解”，将有希望得到正确的最终解决方案，也称为“全局最优解”。
	包括JavaScript在内的众多语言，不能高效的将递归代码解释为机器代码，尽管写出来的程序简洁，但是执行效率低下。本质上来说，那些指令式编程语言和面向对象的编程语言对递归的实现不够完善，因为它们没有将递归作为高级编程的特性。
	许多实用递归去解决的编程问题，可以重写为实用动态规划的技巧去解决。动态规划方案通常会使用一个数组来建立一张表，用于存放被分解为众多子问题的解，当算法执行完毕，最终的解将会在这个表中很明显的地方被找到。
	../Senior/recurFib.js
		斐波那契数列,递归计算解法。
	../Senior/dynFib.js
		斐波那契数列,动态规划解法。
	../Senior/compareFib.js(依赖../Senior/recurFib.js)(依赖../Senior/dynFib.js)
		斐波那契数列，递归计算解法和动态规划解法的时间比较。
		动态规划的解决方案要比递归的解决方案更加高效，计算fib(20)更大的数字差距明显。
	../Senior/iterFib.js
		斐波那契数列，迭代方法，可以不使用数组。效率和动态规划一样。
	../Senior/lcs.js
		寻找两个字符串的最长公共子串，动态规划方法。
	../Senior/knapsack.js
		背包问题，递归计算解法。
	../Senior/dKnapsack.js
		背包问题，动态规划解法。
	../Senior/makeChange.js
		找零问题，贪心算法。原来js小数书写的时候，个位的0可以省略。
	../Senior/ksack.js
		背包问题，贪心算法。针对不需要离散计数的物品，如面粉。这里数组的顺序已经是按照价值比率从大到小排好序的了，所以从开头处理即可。
	【练习】
	../Senior/Exercise/lcsBrute.js
		暴力方法寻找最长公共子串。
	练习2修改dKnapsack.js的参数即可。
	../Senior/Exercise/makeChange1.js
		修改makeChange.js，却发现结果出错。由于浮点数的计算有精度缺失，导致结果不准。将美分数都乘以100，转化为整数的运算。